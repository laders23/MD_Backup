# **컴퓨터 구조 개념 정리 (남재열 교수님)**

## __1장. 컴퓨터 시스템 개요__

### 1.1 컴퓨터의 기본 구조

### 1.2 정보의 표현과 저장

### 1.3 시스템의 구성

### 1.4 컴퓨터구조의 발전과정

---

## **1.1 컴퓨터의 기본 구조**

<br>

### **[컴퓨터 시스템의 구성]**

- 응용 소프트웨어 (Application Software)
- 시스템 소프트웨어 (System Software)
- 하드웨어(Hardware)

<br>

### **[하드웨어와 소프트웨어]**

하드웨어(Hardware)

- 컴퓨터 정보들의 전송 통로를 제공, 그 정보에 대한 처리가 실제 일어나게 해주는 물리적 실체들

소프트웨어(Software)

- 정보들이 이동하는 뱡향, 정보 처리의 종류 지정  
   -> 그러한 동작들이 일어나는 시간을 지정해주는 명령(Command)들의 집합

  **1. 시스템 소프트웨어(System Software)**  
   = OS(Windows 10, Unix, Linux 등), 각종 유틸리티 프로그램들(프린터 드라이버 등)

  **2. 응용 소프트웨어(Application Software)**  
   = 워드프로세서, 웹브라우저, MS-Excel 등

### **[컴퓨터 하드웨어의 주요 요소들]**

    1. 메인 보드(Main Board)
    2. CPU 및 GPU 칩
    3. 주기억장치 모듈
    4. 확장 보드 : 사운드 카드 등
    5. 전원공급장치(Power Supply)
    6. 광 저장장치: CD-ROM, DVD
    7. 하드 디스크, SSD
    8. 키보드
    9. 마우스
    10. 디스플레이 모니터

### **[컴퓨터의 기본 구조 (굿노트 참조)]**

- 컴퓨터의 기능
  > 프로그램 코드를 정해진 순서대로 수행 = 데이터를 읽어서(Read), 처리(Processing)하고, 저장(Store)한다.
- 주요 구성요소들
  > 중앙처리장치, 기억장치, 입출력장치

### **[컴퓨터의 기본적인 구성요소들]**

- 중앙처리장치(Central Processing Unit: CPU)

  > 프로세서(Processor) : '프로그램 실행'과 '데이터 처리'라는 중추적인 기능의 수행을 담당하는 요소

    <br>

- 기억장치
  - 주기억장치(Main Memory)
    > - CPU 가까이 위치하며, 반도체 기억장치 칩들로 구성
    > - 고속 액세스
    > - 가격이 높고 면적을 많이 차지 -> 저장 용량의 한계
    > - 영구 저장 능력 X, 일시적 저장장치로만 사용 (휘발성 메모리)
  - 보조저장장치(Auxiliary Storage Device)
    > - 2차 기억장치(Secondary Memory)
    > - 저장 밀도 우수, 비트 당 가격 저렴
    > - 읽기/쓰기 속도 느림
    > - 영구 저장 능력을 가진 저장장치: 하드 디스크(Hard Disk), 플래시 메모리(Flash Memory), SSD(Solid-State Drive), CD-ROM 등

<br>

- 입출력장치(I/O Device)
  > - 입력장치(Input Device)와 출력장치(Output Device)의 통칭
  > - 사용자-컴퓨터 간의 상호작용(Interaction)을 위한 장치들
  > - CPU는 해당 장치 제어기(Device Controller)를 통하여 동작 제어
  > - 주변장치(Peripheral Device)라고도 부름

---

## **1.2 정보의 표현과 저장**

**[컴퓨터 정보]**

- 2진수 비트들로 표현된 프로그램 코드와 데이터  
  <br>

**[프로그램 코드]**

- 기계어(Machine Language)

  > 기계 코드(Machine Code)라고도 함  
  > 컴퓨터 하드웨어 부품들이 이해할 수 있는 언어로서, 2진 비트들로 구성

- 어셈블리 언어(Assembly Language)

  > 고급 언어와 기계어 사이의 중간 언어
  > 어셈블러(Assembler)로 변역되며, 기계어와 1:1 대응

- 고급 언어(High-Level Language)
  > 영문자와 숫자로 구성되어 사람이 이해하기 쉬운 언어  
  > C, C++, PASCAL, FORTRAN, JAVA 등  
  > 컴파일러(Compiler)를 이용하여 기계어로 번역

**[프로그램 언어의 번역 과정]**  
 ex) Z = X + Y

> - LOAD A, X : 기억장치 X번지의 내용을 읽어서, 레지스터 A에 적재(load)
> - ADD A, Y : 기억장치 Y번지의 내용을 읽어서, 레지스터 A에 적재된 값과 더하고, 결과를 다시 A에 적재
> - STOR Z, A : 그 값을 기억장치 Z번지에 저장(Store)

**[프로그램 언어 번역과정 순서]**

- 고급 언어 프로그램 -> 어셈블리 프로그램 -> 기계어 프로그램

**[프로그램 언어 번역 소프트웨어]**

- 컴파일러(Compiler)
  > 고급언어 프로그램을 기계어 프로그램으로 번역하는 소프트웨어
- 어셈블러(Assembler)
  > 어셈블리 프로그램을 기계어 프로그램으로 번역하는 소프트웨어
  > 니모닉스(Mnemonics)
  >
  > - 어셈블리 명령어가 지정하는 연산을 가리키는 알파벳 기호
  > - 'LOAD', 'ADD', 'STOR' 등

**[기계 명령어의 형식]**  
ex)
|연산코드|오퍼랜드|
|:---:|:---:|
|001|00101|

- 연산 코드(OP-Code[Operation-Code])

  > CPU가 수행할 연산을 지정해주는 비트들
  > 비트수 = '3'이라면, 지정될 수 있는 연산의 최대 수 : 2^3 = 8개

- 오퍼랜드(Operand)
  > 연산에 사용될 데이터 혹은 그것이 저장되어 있는 기억장치 주소(Memory Address)
  > 비트 수 = '5'라면, 주소지정(Addressing) 할 수 있는 기억 장소의 최대 수 : 2^5 = 32개

**[프로그램 코드와 데이터의 기억장치 저장]**

- 프로그램 코드(명령어)와 데이터는 지정된 기억 장소에 저장
- 단어(Word) 단위로 저장
  > - 단어: 각 기억장소에 저장되는 정보의 기본 단위로서, CPU에 의해 한 번에 처리될 수 있는 비트들의 그룹
  > - 단어 길이의 예 : 8비트, 32비트, 64비트, 128비트
  > - 주소지정 단위 : 단어 단위 혹은 바이트(Byte) 단위

---

## **1.3 시스템의 구성**

### **1.3.1 CPU와 기억장치의 접속**

**[시스템 버스(System Bus)]**

- CPU와 시스템 내의 다른 요소들 사이에 정보를 교환하는 통로

  [기본구성]

  - 주소 버스(Address Bus)
  - 데이터 버스(Date Bus)
  - 제어 버스(Control Bus)

    <br>

- 주소 버스(Address Bus)
  > - CPU가 외부로 발생하는 주소 정보를 전송하는 신호 선들의 집합
  > - 주소 선의 수는 CPU와 접속될 수 있는 최대 기억장치 용량을 결정
        - ex) 주소 버스의 비트 수 = 16비트 -> 최대 2^16 = 64K개 기억 장소들의 주소지정 가능
- 데이터 버스(Data Bus)
  > - CPU가 기억장치 혹은 I/O 장치와의 사이에 데이터를 전송하기 위한 신호 선들의 집합
  > - 데이터 선의 수는 CPU가 한 번에 전송할 수 있는 비트 수를 결정
        ex) 데이터 버스 폭 = 32 비트 -> CPU와 기억장치 간의 데이터 전송은 한 번에 32 비트씩 가능
- 제어 버스(Control Bus)
  > - CPU가 시스템 내의 각종 요소들의 동작을 제어하기 위한 신호 선들의 집합
        ex)
            - 기억장치 읽기/쓰기(Memory Read/Write) 신호
            - I/O 읽기/쓰기(I/O Read/Write) 신호
            - 인터럽트(Interrupt) 신호
            - 버스 제어(Bus Control) 신호

<br>

**[CPU와 시스템 버스 간의 접속]**

- 주소 버스 : 단방향성(Unidirectional)
  > - 주소는 CPU로부터 기억장치 혹은 I/O 장치들로 보내지는 정보
- 데이터 버스, 제어 버스 : 양방향성(Bidirectional)
  > - 읽기와 쓰기 동작을 모두 지원

<br>

**[CPU와 기억장치 간의 접속]**

- 필요한 버스 및 제어신호
  > - 주소버스
  > - 데이터 버스
  > - 제어신호 : 기억장치 읽기(Memory Read) 신호, 기억장치 쓰기(Memory Write) 신호
- 기억장치 쓰기 동작
  > CPU가 데이터를 저장할 기억 장소의 주소, 데이터 -> 각각 주소 버스/데이터 버스 를 통하여 보내는 동시에, 쓰기신호 활성화
- 기억장치 쓰기 시간(Memory Write Time)
  > CPU가 주소와 데이터를 보낸 순간부터 저장이 완료될 때 까지의 시간
- 기억장치 읽기 동작
  > - CPU가 기억장치 주소 -> 주소 버스를 통하여 보냄과 동시에 읽기신호 활성화
  > - 일정 지연 시간 경과 후, 기억장치로부터 읽혀진 데이터  
  >   -> 데이터 버스  
  >   => CPU는 그 데이터를 버스 인터페이스 회로를 통해 읽음
- 기억장치 읽기 시간(Memory Read Time)
  > 주소를 발생한 시간부터, 기억장치의 데이터가 CPU까지 도착할 때까지의 시간

## __1.3.2 CPU와 I/O 장치의 접속__
- 필요한 버스 및 제어 신호
  - 주소 버스
  - 데이터 버스
  - 제어 신호 : I/O 읽기 신호, I/O 쓰기 신호
  > 물론, 읽기와 쓰기를 동시에 활성화 하는 기법을 사용 할 수도 있지만, 메모리가 반토막나게 됨.
- 접속 경로 : CPU <-> 시스템 버스 <-> I/O 장치 제어기 <-> I/O 장치

__[I/O장치 접속 사례 : CPU - 키보드 & 프린터]__
> 데이터 레지스터 -> CPU -> ready 신호를 보내면 상태 레지스터가 동작  
> - (단, 이때 만약 ready가 되지 않는 경우에 CPU에 반복해서 요청을 하게 됨.)  

> 또한, 각 장치들에서 제어기를 따로 가지고 있는 경우가 많은데,  
이는 Direct로 연결하게 되었을 때, CPU의 역할이 너무 많아져 각기 장치들이 제어기를 따로 가지게 되어 있다.

__[I/O장치 제어기(I/O Device Controller)]
- 기능 : CPU로부터 I/O 명령을 받아서, 해당 I/O 장치를 제어, 데이터를 이동
  -> 명령을 수행하는 전자회로 장치
- 상태 레지스터
  - I/O 장치의 현재 상태를 나타내는 비트들을 저장한 레지스터
  - 준비 상태(RDY) 비트, 데이터 전송확인(ACK) 비트 등,
- 데이터 레지스터
  - CPU와 I/O 장치 간에 이동되는 데이터를 일시적으로 저장하는 레지스터

__[키보드의 데이터 입력과정]__
- 키보드 제어기
  - 키보드의 어떤 한 키(key)를 누르면, 그 키에 대응되는 ASCII 코드 -> 키보드 제어기의 데이터 레지스터에 저장  
  -> 동시에 상태 레지스터의 In_RDY 비트 = 1로 세트
- CPU
  - 1. 키보드 제어기로부터 상태 레지스터의 내용을 읽어 In_RDY비트가 세트되었는지 검사  
    -> 이때, In_RDY 비트는 데이터 레지스터 외부로부터 데이터가 적재되었는지를 표시
  - 2. 만약 세트되지 않았다면, 1번을 반복하여 대기. 만약 세트되었다면 데이터 레지스터를 읽음

__[프린터의 데이터 출력 과정]__
- CPU
  - 1. 프린트 제어기의 상태 레지스터의 내용을 읽어서 Out_RDY 비트 검사  
    -> 이때, Out_RDY 비트 = 프린터가 출력할 준비가 되었는지를 표시
  - 2. 만약 세트 되지 않았다면 1번을 반복하며 대기,  
    -> 세트 되었다면, 프린트할 데이터를 프린터 제어기의 데이터 레지스터에 저장  
    (데이터 블록 전체를 제어기 내의 데이터 기억장치에 저장하는 것도 가능 : Spooling)
- 프린터 제어기
  - 1. 데이터 레지스터(혹은 데이터 기억장치)의 내용을 프린터로 보내고,
  - 2. 프린터의 하드웨어를 제어하면서 인쇄 동작 수행

__[CPU와 보조저장장치의 접속]__
- 보조저장장치들(디스크, 플래시 메모리, SSD, CD-ROM 등) 도각 장치를 위한 제어기를 통하여 키보드나 프린터와 유사한 방법으로 접속
- 차이점 : 데이터 전송 단위
  - 키보드 : 바이트 단위 전송
  - 보조저장장치 : 블록(512/1024/4096 바이트) 단위로 전송  
    -> 제어기 내에 한 블록 이상을 임시 저장할 수 있는 데이터 기억 장치(버퍼) 필요

## __1.3.3 컴퓨터 시스템의 전체 구성__
- CPU
- 주기억장치
- 디스크 제어기(기본적으로 2개의 레지스터를 가짐 [상태, 데이터])
- 키보드 제어기
- SSD 제어기
- 프린터 제어기

__[컴퓨터의 기본적인 기능들]__
- 프로그램 실행 : CPU가 주기억장치로부터 프로그램 코드를 읽어서 실행
- 데이터 저장 : 프로그램 실행 결과로서 얻어진 데이터를 주기억장치에 저장
- 데이터 이동 : 디스크 혹은 CD-ROM에 저장되어 있는 프로그램과 데이터 블록을 기억장치로 이동
- 데이터 입력/출력 : 사용자가 키보드를 통하여 보내는 명령이나 데이터를 읽어 들인다.  
  -> 또한, CPU가 처리한 결과값, 기억장치의 내용을 프린터(혹은 모니터)로 출력
- 제어 : 프로그램이 순서대로 실행되도록 또는 필요에 따라 실행 순서를 변경하도록 조정, 각종 제어 신호들을 발생

---

<br>

## __1.4 컴퓨터 구조의 발전 과정__
- 주요 부품들의 발전 과정
  - 릴레이(Relay) -> 진공관 -> 트랜지스터 -> 반도체 집적회로(IC)
  - 발전 과정에서 개선된 특징들
    - 처리속도 향상
    - 저장용량 증가
    - 크기 감소
    - 가격 하락
    - 신뢰도 향상  
    -> (여러 칩셋을 연결하게 되면 아무래도 문제점이 높아지게 되는데, 하나의 칩셋으로도 그만큼의 성능을 뽑을 수 있기 때문)
- 초기 컴퓨터들의 근본적인 설계 개념, 동작 원리 = 현대의 컴퓨터

__[최초의 컴퓨터]__
- 1642, Blaise Pascal(프랑스)
- 덧셈/뺄셈을 수행하는 기계적 카운터
- 다이얼의 위치에 의하여 십진수를 표시하는 6개의 원형판 세트로 구성
- 각 원형판은 일시적으로 숫자를 기억하는 레지스터로 사용

__[Leibniz의 기계]__
- 1671, Gottfried Leibniz(독일)
- 덧셈/뺄셈 및 곱셈/나눗셈도 가능한 계산기
- Pascal의 계산기에 두 개의 원형판을 추가 -> 반복적 방법 --> 곱셈/나눗셈 수행
- 이후 많은 계산기계의 조상

__[Difference Engine]__
- 19세기 초, Charles Babbage(영국, 현대 컴퓨터의 할아버지)
- 표에 있는 수들을 자동적으로 계산, 그 결과를 금속 천공기를 거쳐 프린트
- 덧셈/뺄셈만 수행 가능

__[Analytical Engine]__
- 19세기 초, Charles Babbage(영국)
- 주요 특징들
  - 어떤 수학 연산도 자동적으로 수행할 수 있는 일반목적용 계산 기계
  - 프로그래밍 가능 : 프로그램 언어 사용
  - 프로그램의 실행 순서 변경 가능
    - 수의 부호 검사를 이용한 조건 분기
    - 제어 카드를 이용한 실행 순서 변경
- 문제점
  - 주요 부품들이 기계적 장치라 속도가 느리고 신뢰도가 낮음.

__[Analytical Engine의 기본 구조]__
- 산술연산장치 : MILL
- 기억장치 : STORE
- 입력장치 : 카드판독기
- 출력장치 : 카드 천공기, 프린터


__[ENIAC]__
- Electronic Numerical Integrator And Computer
- 1940년대 초, von Neumann(폰 노이만) 개발
- 펜실바니아 대학에서 개발한 진공관을 사용한 최초의 전자식 컴퓨터
- 문제점 : 프로그램의 저장 및 변경 불가능
- 폰 노이만의 설계 개념(stored-program 원리) 발표
  - 프로그램과 데이터를 내부에 저장
  - 2진수 체계(binary number system) 사용
  - 1945년 발표 후, EDVAC(Electronic Discrete Variable Computer) 개발에 실제 적용

__[IAS 컴퓨터]__
- 1946 ~ 1952년 : 폰 노이만이 IAS에서 개발
  - 폰 노이만 : 프린스턴대학 및 IAS(Institute for Advanced Studies)의 수학 교수
- 프로그램 저장/변경이 가능한 최초의 디지털 컴퓨터
- 주요 구성요소
  - 프로그램 제어 유니트(Program Control Unit): 명령어 인출/해독
  - 산술논리연산장치(ALU)
  - 주기억장치 : 명령어와 데이터를 모두 저장
  - 입출력장치

__[IAS 컴퓨터의 구조]__
- 폰 노이만 아키텍쳐(von Neumann Architecture): 프로그램 코드들 -> 기억장치에 저장된 순서대로 실행,  
그 주소는 CPU의 내부 레지스터인 프로그램 카운터(Program Counter)에 의해 지정됨.  
(굿노트 사진 참고)

---
<br>

## __1.4.2 주요 컴퓨터 부품들의 발전 경위__
- 트랜지스터(transistor)
  - 초기(제 1세대) 전자식 컴퓨터의 핵심 부품인 진공관을 대체한 전자 부품
  - 진공관보다 작고 싸며 더 적은 열을 발산
  - 반도체 재료인 실리콘(Si)으로 만들어진 고체 (solid-state) 장치
  - 제 2세대 컴퓨터들의 핵심 부품
  - 초기 컴퓨터들은 약 1000개의 트랜지스터들로 구성
- 집적 회로(Integrated Circuit : IC)
  - 수만 개 이상의 트랜지스터들을 하나의 반도체 칩에 집적시킨 전자부품
  - 제 3세대 컴퓨터들의 핵심 부품

__[집적도에 따른 IC의 분류]__
- SSI(Small Scale IC)
  - 수십 개의 트랜지스터들이 집적되는 소규모 IC
  - 최근에는 주로 기본적인 디지털 게이트(digital gate)들을 포함하는 칩으로만 사용됨
- MSI(Midium Scale IC)
  - 수백 개의 트랜지스터들이 집적되는 IC
  - 카운터(Counter), 해독기(Decoder) 또는 시프트 레지스터(Shift Register)와 같은 조합 회로나 순차 회로를 포함하는 칩
- LSI(Large Scale IC)
  - 수천 개의 트랜지스터들이 집적되는 대규모 IC
  - 8-비트 마이크로프로세서 칩이나 소규모 반도체 기억장치 칩
- VLSI(Vert Large Scale IC)
  - 수만 내지 수십만 개 이상의 트랜지스터들이 집적되는 초대규모 IC
  - 제 4세대 컴퓨터들의 부품
  - 마이크로프로세서 칩들과 대용량 반도체 기억장치 칩
- ULSI(Ultra Large Scale IC)
  - 수백만 개 이상의 트랜지스터들이 집적되는 32-비트급 이상 마이크로프로세서 칩들과 수백 메가비트 이상의 반도체 기억장치 칩들 및 앞으로 출현할 고밀도 반도체 칩들을 지칭하기 위한 용어로서, VVLSI(VeryVery Large Scale IC)라고도 불림

__[IC 사용에 따른 이점]__
- 전기적 통로가 짧아짐 -> 동작 속도가 크게 상승
- 컴퓨터 크기의 감소
- 칩 내부의 회로들 간의 상호 연결 -> 부품들의 신뢰도 향상
- 전력소모 감소 / 냉각장치의 소형화
- 컴퓨터 가격 하락
- VLSI의 출현으로 개인용 컴퓨터(PC)가 개발됨

## __1.4.3 컴퓨터시스템의 분류와 발전 동향__
- 1) 개인용 컴퓨터(PC)
  - 특징
    - 소형, 저가
    - 성능 : 수십 년전의 대형 메인프레임 컴퓨터의 성능을 능가
  - 주요 발전 동향
    - 성능이 개선된 새로운 마이크로프로세서들의 등장에 따라 PC의 성능은 계속 향상
    - 8-비트, 16-비트, 32-비트 CPU 사용 -> 단어 길이 증가, 64-비트 단위의 데이터 처리 및 기억장치 주소 사용 PC들도 출시중
    - 프로세서가 다수의 명령어 실행 유니트들 혹은 CPU코어들을 포함하는 슈퍼스칼라, 듀얼-코어 및 멀티-코어 구조로 발전
    - 칩의 집적도가 높아지면서 주변 요소들이 CPU 칩 내부에 포함됨에 따라 속도와 신뢰도 향상
    - GPU(Graphic Processing Unit)2)를 계산보조장치로 사용 -> 고속 그래픽 처리, 복잡한 과학기술 계산 높은속도로 처리 가능
    - 주기억장치와 보조저장장치의 용량 증가, 종류 다양화
  - 종류(유형)
    - 데스크탑(Desktop)컴퓨터, 노트북(Notebook) 컴퓨터, 넷북(Netbook), 태블릿(Tablet) PC, 포켓(Pocket) PC 등
- 2) 임베디드 컴퓨터
  - Embedded Computer(내장 컴퓨터라고도 부름)
  - 기계 장치나 전자 장치들의 내부에 포함 -> 그 장치들의 동작을 제어(Control)하는 컴퓨터들  
    -> ex) 가전제품, 컴퓨터 주변기기, 모바일폰, 비디오 게임기 등
  - 8-비트 마이크로컨트롤러(Micro-Controller)를 이용한 초소형부터 32-비트 컴퓨터에 이르기까지 다양
  - 최소의 비용, 필요한 만큼의 성능 제공
  - 실시간 처리(Real-Time Processing)
  - IoT(Internet of Things) 및 지능형 로봇의 핵심 요소로 사용되어 더욱 다양해지고 보급도 확대될 전망

- 3) 서버급 컴퓨터시스템
  - 워크스테이션(Workstation)
    - CPU : 64-비트 마이크로프로세서 사용
    - 고속 그래픽 처리 하드웨어 포함
    - 주요 응용 : 3차원 동영상처리, 시물레이션, 컴퓨터 이용 설계(CAD)
    - OS : UNIX, LINUX
  - 슈퍼미니컴퓨터(Super-Minicomputer)
    - 시스템 구조 : 다중프로세서(Multiprocessor) 구조
    - CPU의 수 : 20 ~ 30개
    - 성능 : VAX-11 미니컴퓨터 성능의 수십 배 이상
    - OS : UNIX
    - 서버(server)급 시스템의 다운사이징(downsizing)화 주도
      -> 네트워크에 접속된 다수의 중형급 컴퓨터 시스템들을 응용(혹은 용도)별로 구분하여 사용하는 컴퓨팅 환경이 가능해지게 함
- 4) 메인프레임 컴퓨터(Mainframe Computer)
  - 중앙집중식 컴퓨팅을 위한 대형 컴퓨터
  - IBM 360 / 370 계열, 3081, 3090 등으로 계속 발전, 최근 시스템 보안 및 통신 기능이 대폭 보강된 IBM zEnterprise 계열 출현
  - 대용량 저장장치 보유
  - 다중 I/O 채널을 이용한 고속 I/O 처리 능력 보유
  - 대규모 데이터베이스 저장 및 관리용으로 사용
  - 정부기관, 은행, 대형 인터넷포탈사이트 등에서 대규모 데이터베이스(빅데이터) 저장 및 관리용으로 사용
- 5) 슈퍼컴퓨터(Supercomputer)
  - 현존하는 컴퓨터들 중에서 처리 속도와 기억장치 용량이 다른 컴퓨터들에 비하여 상대적으로 월등한 컴퓨터 시스템들
  - 분류 기준: 계속적으로 상승
    - 최초의 슈퍼컴퓨터인 CRAY-1의 속도는 100MFLOPS
    - 최근의 슈퍼컴퓨터들의 속도는 PFLOPS급(수백만배 향상)
  - 주요 응용 분야들
    - VLSI 회로 설계, 항공우주공학, 천문학(일기 예보), 구조 공학, 유전 탐사, 핵공학, 인공지능, 입체 영상처리 등과 같은 대규모 과학 계산 및 시뮬레이션
  
__구조적 특징에 따른 슈퍼컴퓨터의 분류__
- 파이프라인 슈퍼컴퓨터(Pipeline Supercomputer)
  - 초기의 슈퍼컴퓨터 구조
  - 복잡한 초고속 연산회로들이 포함된, 적은 수의 CPU들로 구성
  - 연산장치 : 슈퍼파이프라인 구조를 이용하여 고속 벡터 계산 수행
  - 대표적인 시스템들 : CRAY Y-MP, CRAY-2, Fujitsu VP 2000, VPP500등
- 대규모 병렬컴퓨터(Massively Parallel Computer:MPP)
  - 상호연결된 수백/수천 개 이상의 범용 프로세스들로 구성
  - 프로세서들이 하나의 큰 작업을 분담하여 동시에 처리하는 병렬처리(Parallel Processing) 기술 이용
  - 시스템 사례 : IBM BlueGene/Q 슈퍼컴퓨터
    - 1,572,864개의 64-비트 PowerPC 프로세서들 탑재
    - 속도: 20PFLOPS, 기억장치 : 1.57 PByte
    - 96캐비닛 x 512노드 x 32 프로세서
  - IBM Summit 슈퍼컴퓨터(2018년 11월 List 세계 1위)
    - 컴퓨터 노드: 24-코어 POWER9 CPU 및 NVIDIA Volta GPU들로 구성 -> 노드당 40 TFLOPS 성능
    - 전체 3400노드 -> 코어 수 = 240만 개
    - 최고속도 : 200PFLOPS
    - 초고속 연결망인 NVLink를 이용하여 CPU-GPU 결합
    - 혼합형 계산(Heterogeneous Computing) 방식 이용
- 클러스터 컴퓨터(Cluster Computer)
  - 고속 LAN이나 네트워크 스위치에 의해 서로 연결된 PC들 혹은 워크스테이션들의 집합체
  - 클러스터 미들웨어(Cluster Middleware)를 이용하여 노드(단위컴퓨터)들에 포함된 모든 자원들을 단일 시스템 이미지(Single System Image : SSI)로 통합
  - 저렴한 가격으로 고성능, 고신뢰 병렬 컴퓨팅 환경 구축가능
  - 대형 웹서버 및 슈퍼컴퓨터 설계 개념으로 널리 사용중

---
<br>

## __2장 CPU의 구조와 기능__
### 2.1 CPU의 기본 구조
### 2.2 명령어 실행
### 2.3 명령어 파이프라이닝
### 2.4 명령어 세트

---

<br>

__CPU의 기능__
- 명령어 인출(Instruction Fetch) : 기억장치로부터 명령어를 읽어온다
- 명령어 해독(Instruction Decode) : 수행해야 할 동작을 결정하기 위하여 명령어를 해독한다  
  => 모든 명령어들에 대하여 공통적으로 수행
- 데이터 인출(Data Fetch) : 명령어 실행을 위해, 데이터가 필요한 경우 -> 기억장치 혹은 I/O 장치로부터 그 데이터를 읽어옴
- 데이터 처리(Data Process) : 데이터에 대한 산술적 혹은 논리적 연산을 수행
- 데이터 저장(Data Store) : 수행한 결과를 저장  
  => 명령어에 따라 필요한 경우에만 수행

---

<br>

### __2.1 CPU의 기본구조__
- 산술논리연산장치(Arithmetic and Logical Unit : ALU)
- 레지스터 세트(Register Set)
- 제어 유니트(Control Unit)

__CPU의 내부 구성요소__
- ALU
  - 각종 산술 연산들과 논리 연산들을 수행하는 회로들로 이루어진 하드웨어 모듈
  - 산술 연산 : +, - , *, /
  - 논리 연산 : AND, OR, NOT, XOR 등
- 레지스터(Register)
  - 액세스 속도가 가장 빠른 기억장치
  - CPU 내부에 포함할 수 있는 레지스터들의 수가 제한(특수 목적용 레지스터들과 적은수의 일반 목적용 레지스터들)
  - 제어 유니트
    - 프로그램 코드(명령어)를 해석하고, 그것을 실행하기 위한 제어 신호들(Control Signals)을 순차적으로 발생하는 하드웨어 모듈
  - CPU 내부 버스(CPU Internal Bus)
    - ALU와 레지스터들 간의 데이터 이동을 위한 데이터 선들과 제어 유니트로부터 발생되는 제어 신호 선들로 구성된 내부 버스
    - 외부의 시스템 버스들과는 직접 연결되지 않으며, 반드시 버퍼레지스터들 혹은 시스템 버스 인터페이스 회로를 통하여 시스템 버스와 접속

---
<br>

### __2.2 명령어 실행__
- 명령어 사이클(Instruction Cycle): CPU가 한 개의 명령어를 실행하는 데 필요한 전체 처리 과정으로서, CPU가 프로그램 실행을 시작한 순간부터 전원을 끄거나 회복불가능한 오류가 발생하여 중단될 때 까지 반복
- 두개의 부사이클(SubCycle)들로 분리
  - 인출 사이클(Fetch Cycle): CPU가 기억장치로부터 명령어를 읽어오는 단계
  - 실행 사이클(Execution Cycle): 명령어를 실행하는 단계

__명령어 실행에 필요한 CPU내부 레지스터들__
- 프로그램 카운터(Program Counter: PC)
  - 다음에 인출할 명령어의 주소를 가지고 있는 레지스터
  - 각 명령어가 인출된 후에는 자동으로 일정 크기(한 명령어 길이)만큼 즈악
  - 분기(Branch) 명령어가 실행되는 경우에는 목적지 주소로 갱신
- 누산기(Accumulator :AC)
  - 데이터를 일시적으로 저장하는 레지스터
  - 레지스터의 길이는 CPU가 한 번에 처리할 수 있는 데이터 비트 수(단어길이)와 동일
- 명령어 레지스터(Instruction Register: IR)
  - 가장 최근에 인출된 명령어 코드가 저장되어 있는 레지스터
- 기억장치 주소 레지스터(Memory Address Register: MAR)
  - PC에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 주소 레지스터
- 기억장치 버퍼 레지스터(Memory Buffer Register: MBR)
  - 기억장치에 쓰여질 데이터 혹은 기억장치로부터 읽혀진 데이터를 일시적으로 저장하는 버퍼 레지스터

---
<br>

### __2.2.1 인출 사이클(Fetch)__
- 인출 사이클의 마이크로 연산(Micro-Operation)
  - t0 : MAR <- PC
  - t1 : MBR <-M[MBR], PC <- PC+1
  - t2 : IR <- MBR
  단, t0,t1및 t2는 CPU 클록(Clock)의 주기  
  [첫 번째 주기] 현재의 PC 내용을 CPU 내부 버스를 통하여 MAR로 전송  
  [두 번째 주기] 그 주소가 지정하는 기억장치 위치로부터 읽혀진 명령엉가 데이터 버스를 통하여 MBR로 적재, PC의 내용에 +1   
  [세 번째 주기] MBR에 있는 명령어 코드가 명령어 레지스터인 IR로 이동  
    -> CPU클록 = 1GHz(클럭주기 = 1ns) => 인출 사이클: 1ns X 3 = 3ns 소요

---
<br>

### __2.2.2 실행 사이클(Execation)__
- CPU는 실행 사이클 동안 명령어 코드를 해독(Decode)하고, 그 결과에 따라 필요한 연산들을 수행
- CPU가 수행하는 연산들의 종류
  - 데이터 이동 : CPU와 기억장치 간 혹은 I/O장치간의 데이터를 이동
  - 데이터 처리 : 데이터에 대하여 산술 혹은 논리 연산을 수행
  - 데이터 저장 : 연산 결과 데이터 혹은 입력장치로부터 읽어들인 데이터를 기억장치에 저장
  - 프로그램 제어 : 프로그램의 실행 순서를 결정
- 실행 사이클에서 수행되는 마이크로-연산들은 명령어의 연산 코드(op-code)에 따라 결정

__기본적인 명령어 형식의 구성__
- 연산 코드(Operation Code)
  - CPU가 수행할 연산을 지정
- 오퍼랜드(Operand)
  - 명령어 실행에 필요한 데이터가 저장된 주소(addr)  

__[사례 1] LOAD addr 명령어__
- 기억장치에 저장되어 있는 데이터를 CPU내부 레지스터인 AC로 이동하는 명령어
  - t0 : MAR <- IR(addr)
  - t1 : MBR <- M[MBR]
  - t2 : AC <- MBR  
  [첫 번째 주기] 명령어 레지스터 IR에 있는 명령어의 주소 부분을 MAR로 전송  
  [두 번째 주기] 그 주소가 지정한 기억장소로부터 데이터를 인출하여 MBR로 전송  
  [세 번째 주기] 그 데이터를 AC에 적재

__[사례 2] STA addr 명령어__
- AC 레지스터의 내용을 기억장치에 저장하는 명령어
  - t0 : MAR <- IR(addr)
  - t1 : MBR <- AC
  - t2 : M[MBR] <- MBR  
  [첫 번째 주기] 데이터를 저장할 기억장치의 주소를 MAR로 전송  
  [두 번째 주기] 저장할 데이터를 버퍼 레지스터인 MBR로 이동  
  [세 번째 주기] MBR의 내용을 MAR이 지정하는 기억장소에 저장  

__[사례 3] ADD addr 명령어__
- 기억장치에 저장된 데이터를 AC의 내용과 더하고, 그 결과는 다시 AC에 저장하는 명령어
  - t0 : MAR <- IR(addr)
  - t1 : MBR <- M[MAR]
  - t2 : AC <- AC + MBR  
  [첫 번째 주기] 데이터를 저장할 기억장치의 주소를 MAR에 전송  
  [두 번째 주기] 저장할 데이터를 버퍼 레지스터인 MBR로 이동  
  [세 번째 주기] 그 데이터와 AC의 내용을 더하고 결과값을 다시 AC에 저장

__[사례 4] JUMP addr 명령어__
- 오퍼랜드(addr)가 가리키는 위치의 명령어로 실행 순서를 변경하는 분기(Branch) 명령어
  - t0 : PC <- IR(addr)
   - 명령어의 오퍼랜드(분기할 목적지 주소)를 PC에 저장
   - 다음 명령어 인출 사이클에서 그 주소의 명령어가 인출되므로, 분기가 발생
  
__어셈블리 프로그램 실행과정의 예__
- 연산 코드에 임의의 정수 배정__
  - LOAD : 1
  - STORE : 2
  - ADD : 5
  - JUMP : 8

  <br>

  __[어셈블리 프로그램의 예]__
  |주소|명령어|기계코드|
  |:---:|:---:|:---|
  |100|LOAD 250|1250|
  |101|ADD 251|5251|
  |102|STA 251|2251|
  |103|JUMP 170|8170|
  - 100번지의 첫 번째 명령어 코드가 인출되어 IR에 저장
  - 250번지의 데이터를 AC로 이동
  - PC = PC+1 = 101
  - 두 번째 명령어가 101번지로부터 인출되어 IR에 저장
  - AC의 내용과 251번지의 내용을 더하고, 그 결과를 AC에 저장
  - PC의 내용은 102로 증가
  - 세 번째 명령어가 102번지로부터 인출되어 IR에 저장
  - AC의 내용이 251번지에 저장
  - PC의 내용은 103으로 증가
  - 네 번째 명령어가 103번지로부터 인출되어 IR에 저장
  - 분기될 목적지 주소, 즉 IR의 하위 부분(170)이 PC로 적재  
  -> (다음 명령어 인출 사이클에서는 170번지의 명령어 인출)
  > 103->170으로 이동했기 때문에, 돌아올 번지수를 저장해 주어야 하는데,  
  > 이 때, PC->Stack Pointer에 메모리를 미리 써두고 끝난 뒤, 다시 104를 꺼내서 복귀하는 방식

---
<br>

### __2.2.3 인터럽트 사이클(Interrupt Cycle)__
- 인터럽트 : 프로그램 실행 중에 CPU의 현재 처리 순서를 중단시키고 다른 동작을 수행하도록 요구하는 시스템 동작
- 외부로부터 인터럽트 요구가 들어오면,
  - CPU는 원래의 프로그램 수행을 중단하고,
  - 요구된 인터럽트를 위한 서비스 프로그램을 먼저 수행
- 인터럽트 서비스 루틴(Interrupt Service Routine: ISR)
  - 인터럽트를 처리하기 위해서 수행되는 프로그램 루틴

__인터럽트에 의한 제어의 이동__
- 인터럽트 발생
- 인터럽트 서비스 루틴 호출
- 복귀(PC에게 주소값을 다시 반환)  
  -> 일시적으로 Stack에 i+1의 주소값을 저장해두었다가 PC에게 주소값을 반환

__인터럽트 처리 과정__
- 인터럽트가 들어왔을 때 CPU는
  - 어떤 장치가 인터럽트를 요구했는지 확인하고, 해당 ISR을 호출
  - 서비스가 종료된 다음에는 중단되었던 원래 프로그램의 수행 계속

- CPU 인터럽트 처리의 세부 동작
  - 1. 현재의 명령어 실행을 끝낸 즉시, 다음에 실행할 명령어의 주소(PC의 내용)를 스택(Stack)에 저장  
    -> 일반적으로 스택은 주기억장치의 특정 부분
  - 2. ISR을 호출하기 위하여 그 루틴의 시작주소를 PC에 적재.  
    -> 이 때, 시작 주소는 인터럽트를 요구한 장치로부터 전송되거나 미리 정해진 값으로 결정
  
__인터럽트 사이클의 마이크로 연산__
- t0 : MBR <- PC
- t1 : MAR <- SP, PC <- ISR의 시작주소
- t2 : M[MAR] <- MBR  
  -> 단, SP는 스택 포인터(Stack Pointer)  
[첫 번째 주기] PC의 내용을 MBR로 전송
[두 번째 주기] SP의 내용을 MAR로 전송하고, PC의 내용은 인터럽트 서비스 루틴의 시작주소로 변경
[세 번째 주기] MBR에 저장되어 있던 원래 PC의 내용을 스택에 저장

__인터럽트 사이클의 마이크로 연산[예]__
- 아래 프로그램의 첫 번째 명령어인 LOAD 250 명령어가 실행되는 동안에 인터럽트가 들어왔으며,  
현재 SP = 999이고, 인터럽트 서비스 루틴의 시작 주소는 650번지라고 가정  
-> (PC에 해당 주소를 바로 얹게되었을 때 기존값이 날아갈 위험이 있어 Stack에 저장을 해준 뒤, 650번지 값을 가지고 이동)

> 100 LOAD 250  
> 101 ADD 251  
> 102 STA 251  
> 103 JUMP 170 
__굿노트 참고__


__다중 인터럽트(Multiple Interrupt)__
- 인터럽트 서비스 루틴을 수행하는 동안에 다른 인터럽트 발생
- 다중 인터럽트의 처리방법 (두 가지)
  - 1. CPU가 인터럽트 서비스 루틴을 처리하고 있는 도중에는 새로운 인터럽트 요구가 들어오더라도 인터럽트 사이클을 수행하지 않는 방법
    - 인터럽트 플래그(Interrupt Flag) <= 0 : 인터럽트 불가능(Interrupt Disable) 상태
    - 시스템 운영상 중요한 프로그램이나 도중에 중단할 수 없는 데이터 입출력 동작 등을 위한 인터럽트를 처리하는데 사용
  - 2. 인터럽트의 우선순위를 정하고, 우선순위가 낮은 인터럽트가 처리되고 있는 동안에 우선순위가 더 높은 인터럽트가 들어온다면, 현재의 인터럽트 서비스 루틴의 수행을 중단하고 새로운 인터럽트를 처리

---

<br>

### __2.2.4 간접 사이클(Indirect Cycle)__
- 명령어에 포함되어 있는 주소를 이용하여, 그 명령어 실행에 필요한 데이터의 주소를 인출하는 사이클  
  -> 간접 주소지정 방식(Indirect Addressing Mode)에서 사용
- 인출 사이클과 실행 사이클 사이에 위치
- 간접 사이클에서 수행될 마이크로-연산
  - t0 : MAR <- IR(addr)
  - t1 : MBR <- M[MBR]
  - t2 : IR(addr) <- MBR
  - 인출될 명령어의 주소 필드 내용을 이용하여 기억장치로부터 데이터의 실제 주소를 인출하여 IR의 주소 필드에 저장

---

<br>

### __2.3 명령어 파이프라이닝(Instruction Pipelining)__
- CPU의 프로그램 처리 속도를 높이기 위하여 CPU 내부 하드웨어를 여러 단계로 나누어 동시에 처리하는 기술
- 2-단계 명령어 파이프라이닝(Two-Stage Instruction Pipelining)
  - 명령어를 실행하는 하드웨어를 인출 단계(Fetch Stage)와 실행 단계(Execute Stage)라는 두 개의 독립적인 파이프라인 모듈로 분리
  - 두 단꼐에 동일한 클록을 가하여 동작 시간을 일치 시키면,
    - 첫 번째 클록 주기에서는 인출 단계가 첫 번째 명령어를 인출
    - 두 번째 클록 주기에서는 인출된 첫 번째 명령어가 실행 단계로 보내져서 실행되며, 그와 동시에 인출 단계는 두 번째 명령어를 인출
- 2-단계 파이프라인을 이용하면 명령어 처리 속도가 2배 향상
- 문제점 : 두 단계의 처리 시간이 동일하지 않으면 두 배의 속도 향상을 얻지 못함 (파이프라인 효율 저하)
  - 해결책 : 파이프라인의 단계의 수를 증가시켜 각 단계의 처리 시간을 같게 함  
    -> 파이프라인 단계의 수를 늘리면 전체적으로 속도 향상이 더 높아짐

__4-단계 명령어 파이프라인__
- 명령어 인출(IF) 단계 : 다음 명령어를 기억장치로부터 인출
- 명령어 해독(ID) 단계 : 해독기(Decoder)를 이용하여 명령어를 해석
- 오퍼랜드 인출(OF) 단계 : 기억장치로부터 오퍼랜드를 인출
- 실행(EX) 단계 : 지정된 연산을 수행
